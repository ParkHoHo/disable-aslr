#  Landa

## Introduction
이 글에서는 XNU 커널의 취약점을 악용하는 방법을 소개합니다.

- CVE-2023-41974 가 할당됨 .
- iOS 17.0 및 macOS 14.0에서 수정되었습니다.
- 앱 샌드박스에서는 접근이 가능하지만 웹 콘텐츠 샌드박스에서는 접근이 불가능합니다.
- 란다는 읽기 전용 매핑에 쓰기를 허용하는 경쟁 조건이었던 P0 이슈 2361과 매우 유사하다는 점에 유의하세요. 구체적으로, vm_map_copy_overwrite_nested()는 대상 범위의 VME를 덮어쓸 수 있는지 확인하지만, vm_map_copy_overwrite_unaligned()는 맵 잠금을 해제하고 다시 가져온 후 동일한 검사를 수행하지 않을 수 있습니다. Landa는 동일한 방식으로 작동하지만 대신 '전환 중'인 VME에 대해 작동합니다.

이 익스플로잇은 다음에서 성공적으로 테스트되었습니다.

iOS 16.5 및 16.5.1(iPhone 14 Pro Max)
macOS 13.4 및 13.4.1(MacBook Air M2 2022)
아래에 표시된 모든 코드 조각은 xnu-8796.101.5 에서 가져온 것입니다 .

## Part A: From Vulnerability to PUAF
익스플로잇의 이 부분은 landa.h에 있는 landa_run() 함수에 레이블이 지정된 3단계로 구성되어 있습니다. 각 단계는 아래에서 자세히 설명하며, 익스플로잇의 특정 지점에서 관련 커널 상태를 보여주는 그림과 함께 설명합니다. 녹색 상자는 VME, 노란색 상자는 VMO, 보라색 상자는 VMC를 나타내며 빨간색 텍스트는 이전 그림과 비교하여 차이점을 강조합니다. 또한 X는 원하는 PUAF 페이지 수를 나타내고 P는 페이지 크기(즉, 16384바이트)를 나타냅니다. 마지막으로, 각 단계에 대한 설명을 읽기 전에 여기서는 반복하지 않으므로 landa_run() 함수에서 해당 코드를 확인하시기 바랍니다.

### STEP 1:
이 단계는 2단계의 경쟁 조건에서 간단히 이길 수 있도록 설정을 담당합니다. 하위 단계 1A에서는 2단계에서 복사본의 소스 범위로 사용될 임의의 주소 A에 (X+2) 페이지의 메모리 영역을 vm_allocate()합니다. 그런 다음 해당 메모리 영역을 아래 목록에 오름차순으로 설명된 세 개의 개별 VME로 분할합니다:

- src_vme_1의 크기는 1페이지이며, src_vm_1에 대한 유일한 참조를 소유하고 있습니다.
- src_vme_2의 크기는 1페이지이며, src_vmo_2에 대한 유일한 참조를 소유합니다.
- src_vme_3의 크기는 X 페이지이며 src_vmo_3에 대한 유일한 참조를 소유합니다.

모든 소스 VME는 VM_FLAGS_PURGABLE 플래그를 사용하여 복사_전략이 MEMORY_OBJECT_COPY_NONE인 퍼지 가능 오브젝트로 초기화됩니다. 또한 전체 소스 범위는 memset()으로 결함이 있습니다. 다음은 하위 단계 1A 이후의 관련 커널 상태의 그림입니다:

하위 단계 1B에서는 2단계에서 마지막 페이지를 제외한 복사본의 대상 범위로 사용될 임의의 주소 B에 (X+3)페이지의 메모리 영역을 vm_allocate()합니다. 그런 다음 해당 메모리 영역을 아래 목록에 오름차순으로 설명된 네 개의 개별 VME로 분할합니다:

- dst_vme_1의 크기는 1페이지이며 dst_vm_o_1에 대한 유일한 참조를 소유합니다. 또한 dst_vme_1->user_wired_count는 간단한 mlock() for-loop를 사용하여 MAX_WIRE_COUNT로 설정됩니다.
- dst_vme_2의 크기는 1페이지이며 dst_vm_o_2에 대한 유일한 참조를 소유하고 있습니다. 또한 vm_remap()으로 자체적으로 리매핑하여 dst_vme_2->is_shared를 TRUE로 설정하고, mlock() 한 번 호출로 dst_vme_2->user_wired_count를 1로 설정할 수 있습니다.

원래는 마지막 (X+1) 페이지에 단일 VME가 할당되지만, 마지막 페이지를 vm_protect()로 읽기 전용으로 표시하여 두 개의 VME로 클립됩니다:

- dst_vme_3의 크기는 X 페이지이며 dst_vm_o_3에 대한 두 개의 참조 중 하나를 소유합니다.
- dst_vme_4는 크기가 1페이지이고 dst_vmo_3의 다른 참조를 소유합니다. 또한 dst_vme_4->protection은 vm_-protect()에 의해 VM_PROT_READ로 설정됩니다.

다시 한 번, 모든 대상 VME는 VM_FLAGS_PURGABLE 플래그를 사용하여 복사 전략이 MEMORY_OBJECT_COPY_NONE인 퍼지 가능한 오브젝트로 초기화된다는 점에 유의하십시오. 또한 dst_vme_4의 읽기 전용 페이지를 제외한 전체 대상 범위가 memset()으로 오류를 일으킵니다. 다음은 하위 단계 1B 이후의 관련 커널 상태를 보여주는 그림입니다:


### STEP 2:

## Part B: From PUAF to KRKW

## Part C: From KRKW to Cleanup

